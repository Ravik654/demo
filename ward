import { Test, TestingModule } from '@nestjs/testing';
import MockAdapter from 'axios-mock-adapter';
import { ContentManagerRetrievalService } from './contentmanager.retrieval.service';
import {
  AXIOS_INSTANCE_TOKEN,
  CommonConfigModule,
  CommonHttpModule,
  CommonTokenModule,
  CommonTokenService,
} from '@primerica/ent-common-nestjs';
import {
  BadRequestException,
  HttpStatus,
  InternalServerErrorException,
  NotFoundException,
} from '@nestjs/common';
import { mock, MockProxy } from 'jest-mock-extended';
import { AxiosInstance, AxiosError } from 'axios';
import { Readable } from 'stream';

describe('ContentManagerRetrievalService', () => {
  let module: TestingModule;
  let service: ContentManagerRetrievalService;
  let mockAxios: MockAdapter;
  let mockCommonTokenService: MockProxy<CommonTokenService>;

  describe('when a valid config provided', () => {
    beforeEach(async () => {
      mockCommonTokenService = mock<CommonTokenService>();
      mockCommonTokenService.getAccessToken.mockResolvedValue('mock-access-token');

      module = await Test.createTestingModule({
        imports: [
          CommonConfigModule.register({
            endpoints: {
              'pri-contentmanagerretrieve-sys': {
                baseUrl: 'https://test-contentmanager.com',
              },
            },
          }),
          CommonHttpModule,
          CommonTokenModule,
        ],
        providers: [ContentManagerRetrievalService],
      })
        .overrideProvider(CommonTokenService)
        .useValue(mockCommonTokenService)
        .compile();

      service = module.get<ContentManagerRetrievalService>(
        ContentManagerRetrievalService
      );

      const axiosInstance = module.get<AxiosInstance>(AXIOS_INSTANCE_TOKEN);
      mockAxios = new MockAdapter(axiosInstance);
    });

    afterEach(() => {
      jest.restoreAllMocks();
      mockAxios.reset();
    });

    describe('retrieveDocument', () => {
      const testId = 'test-document-id';
      const testContentType = 'application/pdf';

      it('should successfully retrieve document and return Readable stream', async () => {
        const mockStream = new Readable();
        mockStream.push('test data');
        mockStream.push(null);

        mockAxios
          .onGet(`https://test-contentmanager.com/documents/${testId}`)
          .reply(HttpStatus.OK, mockStream, {
            'Content-Type': testContentType,
          });

        const loggerSpy = jest.spyOn(service['logger'], 'log');

        const result = await service.retrieveDocument(testId, testContentType);

        expect(result).toBeDefined();
        expect(result).toBeInstanceOf(Readable);
        expect(loggerSpy).toHaveBeenCalledWith(
          `Retrieve Content from Content Manager with Content Type ${testContentType} and ID: ${testId}`
        );
        expect(mockCommonTokenService.getAccessToken).toHaveBeenCalled();
        expect(mockAxios.history.get).toHaveLength(1);
        const request = mockAxios.history.get[0]!;
        expect(request.headers?.['Content-Type']).toBe(testContentType);
        expect(request.headers?.['Authorization']).toBe('Bearer mock-access-token');
      });

      it('should throw NotFoundException when axios error has NOT_FOUND status', async () => {
        mockAxios
          .onGet(`https://test-contentmanager.com/documents/${testId}`)
          .reply(HttpStatus.NOT_FOUND, {
            statusCode: HttpStatus.NOT_FOUND,
            message: 'Document not found',
          });

        await expect(
          service.retrieveDocument(testId, testContentType)
        ).rejects.toThrow(NotFoundException);
      });

      it('should throw NotFoundException when error is NotFoundException instance', async () => {
        const notFoundError = new NotFoundException();
        const axiosInstance = module.get<AxiosInstance>(AXIOS_INSTANCE_TOKEN);
        jest.spyOn(axiosInstance, 'get').mockRejectedValue(notFoundError);

        await expect(
          service.retrieveDocument(testId, testContentType)
        ).rejects.toThrow(NotFoundException);
      });

      it('should throw InternalServerErrorException when axios error has BAD_REQUEST status', async () => {
        mockAxios
          .onGet(`https://test-contentmanager.com/documents/${testId}`)
          .reply(HttpStatus.BAD_REQUEST, {
            statusCode: HttpStatus.BAD_REQUEST,
            message: 'Bad request',
          });

        await expect(
          service.retrieveDocument(testId, testContentType)
        ).rejects.toThrow(InternalServerErrorException);
      });

      it('should throw InternalServerErrorException when error is BadRequestException instance', async () => {
        const badRequestError = new BadRequestException();
        const axiosInstance = module.get<AxiosInstance>(AXIOS_INSTANCE_TOKEN);
        jest.spyOn(axiosInstance, 'get').mockRejectedValue(badRequestError);

        await expect(
          service.retrieveDocument(testId, testContentType)
        ).rejects.toThrow(InternalServerErrorException);
      });

      it('should rethrow error when error is not handled specifically', async () => {
        const genericError = new Error('Generic error');
        const axiosInstance = module.get<AxiosInstance>(AXIOS_INSTANCE_TOKEN);
        jest.spyOn(axiosInstance, 'get').mockRejectedValue(genericError);

        await expect(
          service.retrieveDocument(testId, testContentType)
        ).rejects.toThrow('Generic error');
      });

      it('should handle axios error with undefined response', async () => {
        // Create a network error (no response)
        const axiosInstance = module.get<AxiosInstance>(AXIOS_INSTANCE_TOKEN);
        const networkError = new Error('Network Error') as AxiosError;
        networkError.isAxiosError = true;
        networkError.response = undefined;
        networkError.config = {
          url: `https://test-contentmanager.com/documents/${testId}`,
          headers: {} as any,
        } as any;
        networkError.toJSON = () => ({});

        jest.spyOn(axiosInstance, 'get').mockRejectedValue(networkError);

        // When response is undefined, isAxiosError check passes but err.response?.status fails
        // So it should fall through to the else block and rethrow
        await expect(
          service.retrieveDocument(testId, testContentType)
        ).rejects.toBeDefined();
      });

      it('should call logger.log with correct message', async () => {
        const mockStream = new Readable();
        mockStream.push('test data');
        mockStream.push(null);

        mockAxios
          .onGet(`https://test-contentmanager.com/documents/${testId}`)
          .reply(HttpStatus.OK, mockStream);

        const loggerSpy = jest.spyOn(service['logger'], 'log');

        await service.retrieveDocument(testId, testContentType);

        expect(loggerSpy).toHaveBeenCalledWith(
          `Retrieve Content from Content Manager with Content Type ${testContentType} and ID: ${testId}`
        );
      });

      it('should build request headers with correct Content-Type and Authorization through retrieveDocument', async () => {
        const mockStream = new Readable();
        mockStream.push('test data');
        mockStream.push(null);

        mockAxios
          .onGet(`https://test-contentmanager.com/documents/${testId}`)
          .reply(HttpStatus.OK, mockStream);

        await service.retrieveDocument(testId, testContentType);

        expect(mockCommonTokenService.getAccessToken).toHaveBeenCalled();
        const request = mockAxios.history.get[0]!;
        expect(request.headers?.['Content-Type']).toBe(testContentType);
        expect(request.headers?.['Authorization']).toBe('Bearer mock-access-token');
      });

      it('should use correct URL with baseUrl and document id', async () => {
        const mockStream = new Readable();
        mockStream.push('test data');
        mockStream.push(null);

        mockAxios
          .onGet(`https://test-contentmanager.com/documents/${testId}`)
          .reply(HttpStatus.OK, mockStream);

        await service.retrieveDocument(testId, testContentType);

        expect(mockAxios.history.get[0]!.url).toBe(
          `https://test-contentmanager.com/documents/${testId}`
        );
      });

      it('should set responseType to stream', async () => {
        const mockStream = new Readable();
        mockStream.push('test data');
        mockStream.push(null);

        mockAxios
          .onGet(`https://test-contentmanager.com/documents/${testId}`)
          .reply(HttpStatus.OK, mockStream);

        await service.retrieveDocument(testId, testContentType);

        const request = mockAxios.history.get[0]!;
        expect(request.config?.responseType).toBe('stream');
      });
    });

    describe('buildRequestHeaders', () => {
      it('should return headers with Content-Type and Authorization via private method', async () => {
        const contentType = 'application/json';
        const accessToken = 'test-token-123';
        mockCommonTokenService.getAccessToken.mockResolvedValue(accessToken);

        // Directly invoke the private method using index access
        const headers = await (service as any)['buildRequestHeaders'](contentType);

        expect(mockCommonTokenService.getAccessToken).toHaveBeenCalledTimes(1);
        expect(headers['Content-Type']).toBe(contentType);
        expect(headers['Authorization']).toBe(`Bearer ${accessToken}`);
      });

      it('should call getAccessToken from commonTokenService when building headers', async () => {
        const contentType = 'application/pdf';
        const accessToken = 'another-mock-token';
        mockCommonTokenService.getAccessToken.mockResolvedValue(accessToken);

        await (service as any)['buildRequestHeaders'](contentType);

        expect(mockCommonTokenService.getAccessToken).toHaveBeenCalledTimes(1);
      });

      it('should be used by retrieveDocument to set request headers correctly', async () => {
        const contentType = 'application/xml';
        const accessToken = 'xml-token';
        mockCommonTokenService.getAccessToken.mockResolvedValue(accessToken);

        const mockStream = new Readable();
        mockStream.push('test data');
        mockStream.push(null);

        mockAxios
          .onGet('https://test-contentmanager.com/documents/test-id')
          .reply(HttpStatus.OK, mockStream);

        await service.retrieveDocument('test-id', contentType);

        const request = mockAxios.history.get[0]!;
        expect(request.headers?.['Content-Type']).toBe(contentType);
        expect(request.headers?.['Authorization']).toBe(`Bearer ${accessToken}`);
      });
    });
  });
});

