import { ForbiddenException } from '@nestjs/common';
import { Readable } from 'stream';
import { AgentController } from './agent.controller';

describe('AgentController - getDocument', () => {
  let controller: AgentController;
  let mockUtilsService: { getUserFromToken: jest.Mock };
  let mockAgentsService: { getDocument: jest.Mock };

  const authHeader = 'Bearer some-token';
  const contentType = 'application/pdf';
  const docId = 'DOC-123';

  beforeEach(() => {
    mockUtilsService = {
      getUserFromToken: jest.fn(),
    };

    mockAgentsService = {
      getDocument: jest.fn(),
    };

    // NOTE: The constructor signature is inferred from the controller usage.
    // If the real constructor is different, adjust the arguments accordingly.
    controller = new AgentController(
      mockAgentsService as any,
      mockUtilsService as any,
    );
  });

  it('should allow HomeOffice user to retrieve document and pipe the stream to response', async () => {
    const mockReadable = new Readable({
      read() {
        this.push(null);
      },
    }) as Readable & { pipe: jest.Mock };
    mockReadable.pipe = jest.fn();

    mockUtilsService.getUserFromToken.mockReturnValue({
      loginId: 'LOGIN-1',
      agentId: 'AGENT-2',
      userType: 'HomeOffice' as any, // matches UserType.HomeOffice branch
    });

    mockAgentsService.getDocument.mockResolvedValue(mockReadable);

    const res: any = {};

    await controller.getDocument(authHeader, contentType, docId, res);

    expect(mockUtilsService.getUserFromToken).toHaveBeenCalledWith(authHeader);
    expect(mockAgentsService.getDocument).toHaveBeenCalledWith(docId, contentType);
    expect(mockReadable.pipe).toHaveBeenCalledWith(res);
  });

  it('should allow non-HomeOffice user when agentId matches loginId', async () => {
    const mockReadable = new Readable({
      read() {
        this.push(null);
      },
    }) as Readable & { pipe: jest.Mock };
    mockReadable.pipe = jest.fn();

    mockUtilsService.getUserFromToken.mockReturnValue({
      loginId: 'AGENT-1',
      agentId: 'AGENT-1',
      userType: 'SomeOtherType' as any,
    });

    mockAgentsService.getDocument.mockResolvedValue(mockReadable);

    const res: any = {};

    await controller.getDocument(authHeader, contentType, docId, res);

    expect(mockUtilsService.getUserFromToken).toHaveBeenCalledWith(authHeader);
    expect(mockAgentsService.getDocument).toHaveBeenCalledWith(docId, contentType);
    expect(mockReadable.pipe).toHaveBeenCalledWith(res);
  });

  it('should throw ForbiddenException when user is not HomeOffice and agentId does not match loginId', async () => {
    mockUtilsService.getUserFromToken.mockReturnValue({
      loginId: 'LOGIN-1',
      agentId: 'AGENT-2',
      userType: 'SomeOtherType' as any,
    });

    const res: any = {};

    await expect(
      controller.getDocument(authHeader, contentType, docId, res),
    ).rejects.toBeInstanceOf(ForbiddenException);

    expect(mockAgentsService.getDocument).not.toHaveBeenCalled();
  });
});


